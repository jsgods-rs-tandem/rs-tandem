# 28.02.2026

## Что сделано:

1. Базовый store для работы с локальной моделю
2. Базовый FE для AI Chat

## Проблемы:

1. Библиотека для парсинга markdown
2. display: inline

## Решения, мысли и планы:

Вчера создал компоненты для базовой разметки чата. Когда начал работать над разметкой, всё съезжало, и результат был непредсказуем. Заданная ширина не применялась к компонентам, что бы я ни делал. Лишь спустя какое-то время отладки в DevTools наткнулся на то, что, оказывается, в Angular значение `display` по умолчанию для `:host` — `inline`.

---

Начал думать над реализацией store для своего компонента. Мы с командой приняли решение, что будем использовать Dependency Injection Angular для создания store, вместо NgRx. При прохождении туториалов сразу пришла идея использовать этот механизм для store. Но при первой реализации всё оказалось не так однозначно. Не сразу пришло в голову, в каком формате хранить данные, чтобы они корректно обновлялись и отрисовывались. Тут не Vanilla JS, в которой в любой непонятной ситуации можно было бы пробросить callback.

---

Сегодня продолжил раздумья касательно store. Проблема в том, что у меня были разные виды сообщений: те, что хранились в истории и имели статичный markdown, и те, что писал LLM в stream markdown. Первоначально думал подключать дополнительные библиотеки `ngx-markdown` либо `marked` и использовать `innerHTML` (узнал, что Angular проверяет на безопасность `innerHTM` перед вставкой), и уже на основе работы библиотеки делать компонент для отрисовки статичного markdown. Больше всего смущало в этой идее то, что библиотеки могут по-разному отрендерить markdown.

Почему-то самое очевидное решение пришло мне только через несколько часов раздумий и изучения других библиотек. Я адаптировал предыдущую директиву, чтобы она проверяла данные: является ли это поток, или строка, и в зависимости от типа либо запускала асинхронный цикл, обрабатывая поток, либо считала целую строку за chunk и рисовала её. После этого дело пошло быстрее.

---

В целом Angular продолжает оставлять приятные впечатления от работы с ним (по сравнению с Vanilla JS). Но часто простые вещи оказываются не такими простыми из-за отсутствия опыта работы с фреймворком.

Например, последней фичей на сегодня добавлял автоскролл вниз. В Vanilla JS, очевидно, добавил бы метод на обработку события. Здесь же событий нет, да и в целом, чтобы обратиться к host-элементу внутри скрипта - нужно гуглить.

К счастью, сейчас 2026 год, и под рукой есть ментор, который не устанет отвечать на глупые вопросы, - в виде ChatGPT. Но с Angular все его слова нужно делить пополам и всё равно искать в Google, так как сигналы до него всё ещё не дошли.

##Затраченное время:

~14 часов
